(define-module (language meson parse)
  #:use-module (ice-9 threads)
  #:use-module (ts)
  #:use-module (srfi srfi-1)
  #:use-module (srfi srfi-26)
  #:use-module (srfi srfi-71)
  #:use-module (srfi srfi-171)
  #:use-module (ice-9 pretty-print)
  #:use-module (ice-9 iconv)
  #:use-module (ice-9 textual-ports)
  #:use-module (rnrs bytevectors gnu)
  #:use-module (ice-9 textual-ports)
  #:use-module (system base language)
  #:use-module (system base compile)
  #:use-module (system base target)
  #:use-module (ice-9 match)
  #:export (parse-meson
            read-meson))

(define (parse-meson exp)
  (define retrans
    (lambda (x)
      (parse-meson x)))
  (define (handle-if exp)
    (match exp
      ((("if" "if")
        ("condition" condition)
        expr
        body ...
        ("endif" "endif"))

       `(if ,(retrans condition)
            ,(retrans expr)
            ,(handle-if body)))
      ((("elif" "elif")
        ("condition" condition)
        ("statement_list" . statement_list)
        body ...)
       `(if ,(retrans condition)
            (begin ,@(map retrans statement_list))
            ,(handle-if body)))
      ((("else" "else") expr)
       (retrans expr))
      (else *unspecified*)))

  (match exp
    (("build_definition" . body)
     `(begin ,@(map retrans body)))
    (("comment" str)
     `(comment ,str))
    (("continue" "continue")
     'continue)
    (("break" "break")
     'break)
    (("statement" . body)
     (append-map retrans body))
    (("identifier" name)
     `(%id ,(string->symbol name)))
    (("assignment_statement" ("identifier" name) ("assignment_operator" op) value)
     `(%assignment ,(string->symbol op) ,(string->symbol name) ,(retrans value)))
    (("int_literal" num) (handle-number num))
    (((or "expression" "expression_statement") o)
     (retrans o))
    (("additive_expression" arg1 ("additive_operator" op) arg2)
     (list (string->symbol op) (retrans arg1) (retrans arg2)))
    (("iteration_statement"
      ("foreach" "foreach")
      ("identifier_list" . identifier_list)
      ("expression" exp)
      body ...
      ("endforeach" "endforeach"))
     `(foreach ,(map retrans identifier_list)
               ,(retrans exp)
               (begin ,(map retrans body)) ))
    (("conditional_expression" conditional exp1 exp2)
     `(if ,(retrans conditional) ,(retrans exp1) ,(retrans exp2) ))
    (("primary_expression" exp)
     (retrans exp))
    (("subscript_expression" exp index)
     `(%subscript ,(retrans exp) ,(retrans index)))
    (("logical_and_expression" arg1  (_ op) arg2)
     `(and ;; ,op
       ,(retrans arg1) ,(retrans arg2)))
    (("logical_or_expression" arg1  (_ op) arg2)
     `(or ;; ,op
       ,(retrans arg1) ,(retrans arg2)))
    (("equality_expression" arg1 ("equality_operator" op) arg2)
     `(%equal ,(string->symbol op) ,(retrans arg1) ,(retrans arg2) ))
    (("selection_statement" body ...)
     (handle-if body))
    (("statement_list" . s)
     `(begin ,@(map retrans s)))
    (("multiplicative_expression" exp ("multiplicative_operator" op) exp2)
     (list (string->symbol op) (retrans exp) (retrans exp2)))
    (("dictionary_literal" "{}")
     `(list 'dict))
    (("dictionary_literal" ("key_value_item" k v) ...)
     ;; `(apply list 'dict ,@(fl)
     ;;         '())
     `(list
       'dict
       ,@(zip
          (make-list (length k)
                     'list)
          (map retrans k)
          (map retrans v)))
     )
    (("array_literal" "[]") #())
    (("array_literal" . body)
     `(%vector ,@(map retrans body)))
    (("function_expression" ("identifier" name) . args)
     `(%call
       ,(string->symbol name)
       ,@(append-map (lambda (x)
                       (match (retrans x)
                         (('arg x)
                          (list x))
                         (('karg name value)
                          (list (symbol->keyword name) value))))
                     args)
       ))
    (("unary_expression" ("unary_operator" (op op)) expr)
     `(,(string->symbol op) ,(retrans expr)))
    (("relational_expression" id ("relational_operator" (op op) ...) v)
     `(%relational ,(map string->symbol op) ,(retrans id) ,(retrans v)  ))
    (("relational_expression" id ("relational_operator" op) v)
     `(%relational (,(string->symbol op)) ,(retrans id) ,(retrans v)  ))
    (("argument" expr)
     `(arg ,(retrans expr)))
    (("keyword_argument" ("identifier" id) expr)
     `(karg ,(string->symbol id) ,(retrans expr)))
    (("method_expression" id fe
      ;; ("function_expression" ("identifier" name) . args)
      )
     (let ((f b (match (retrans fe)
                  ((_ name . args)
                   (values name args)))))
       `(,f ,(retrans id)
            ;; %mcall ,(list f (retrans id)

            ;;               )
            ;; ,@(map retrans args)
            ,@b
            )))
    (("string_literal" b)
     (substring b 1 (- (string-length b) 1)))
    (("fstring_literal" b)
     `(fstring ,(substring b 1 (- (string-length b) 1))))
    (("boolean_literal" b)
     (cond ((string= b "true") #t)
           ((string= b "false") #f)
           (else (error))))
    (("multiline_string_literal" b)
     `(fstring ,(substring b 3 (- (string-length b) 3))))
    (else
     `(uh ,exp))))

(define (handle-number n)
  (let ((n (string-downcase n)))
    (string->number
     (cond ((< (string-length n) 2)
            n)
           ((member (substring n 0 2)
                    '("0x" "0b" "0o"))
            (string-replace n "#" 0 1 ))
           (else n)))))

(define (find-child node proc)
  (let* ((er-node (find proc (ts-node-childs node ))))
    (or (and=> er-node (cut find-child <> proc))
        er-node)))

(define parser
  (delay (ts-parser-new
          #:language
          (get-ts-language-from-file

           "/gnu/store/v9ixl7pagm1r5jzsnfid1hjz494pfdk6-tree-sitter-meson-1.2-0.3d6dfbd/lib/tree-sitter/libtree-sitter-meson.so"
           "tree_sitter_meson"))))

(define (read-meson port env)
  (let ((s (get-string-all port)))
    (define (node-string n)
      (substring-utf8
       s
       (ts-node-start-byte n)
       (ts-node-end-byte n)))

    (if (string-null? s)
        the-eof-object
        (let loop ((rn (ts-tree-root-node (ts-parser-parse-string (force parser) s))))
          (when (ts-node-has-error? rn)
            (let ((n (find-child rn ts-node-has-error?)))
              (error 'is-error (node-string n)
                     (ts-node-start-point n)))
            )
          (let ((childs (ts-node-childs rn #t)))
            (if (null? childs)
                (if (ts-node-extra? rn)
                    #f
                    (list (ts-node-type rn)
                          (node-string rn)))
                (if (string=?
                     (ts-node-type rn) "string_literal")

                    (list (ts-node-type rn)
                          (node-string rn))

                    (cons (ts-node-type rn)
                          (filter-map loop childs)))))))))
